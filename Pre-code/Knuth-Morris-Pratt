Knuth-Morris-Pratt
///returns the longest proper prefix array of pattern p
///where lps[i]=longest proper prefix which is also suffix of p[0...i]
vector<int> build_lps(string p)
{
    int sz = p.size();
    vector<int> lps;
    lps.assign(sz + 1, 0);
    int j = 0;
    lps[0] = 0;
    for(int i = 1; i < sz; i++)
    {
        while(j >= 0 && p[i] != p[j])
        {
            if(j >= 1)
                j = lps[j - 1];
            else
                j = -1;
        }
        j++;
        lps[i] = j;
    }
    return lps;
}
vector<int>ans;
///returns matches in vector ans in 0-indexed
void kmp(vector<int> lps, string s, string p)
{
    int psz = p.size(), sz = s.size();
    int j = 0;
    for(int i = 0; i < sz; i++)
    {
        while(j >= 0 && p[j] != s[i])
            if(j >= 1)
                j = lps[j - 1];
            else
                j = -1;
        j++;
        if(j == psz)
        {
            j = lps[j - 1];
            ans.eb(i-psz+1);///pattern found in string s at position i-psz+1
        }
        ///after each loop we have j=longest common suffix of s[0..i] which is also prefix of p
    }
}
int main()
{
    int i,j,k,n,m,t;
    cin>>t;
    while(t--)
    {
        string s,p;
        cin>>s>>p;
        vector<int>lps = build_lps(p);
        kmp(lps, s, p);
        if(ans.empty())
            cout<<"Not Found\n";
        else
        {
            cout<<ans.size()<<nl;
            for(auto x:ans)
                cout<<x<<' ';
            cout<<nl;
        }
        ans.clear();
        cout<<nl;
    }
    return 0;
}

Bitset
///Complexity: n^2/64
vi v;
bitset<N>bs[26],oc;
int main()
{
    fast;
    int i,j,k,n,q,l,r;
    string s,p;
    cin>>s;
    for(i=0; s[i]; i++)
        bs[s[i]-'a'][i]=1;
    cin>>q;
    while(q--)
    {
        cin>>p;
        oc.set();
        for(i=0; p[i]; i++)
            oc&=(bs[p[i]-'a']>>i);
        cout<<oc.count()<<nl;///number of occurences
        int ans=N,sz=p.size();
        int pos=oc._Find_first();
        v.pb(pos);
        pos=oc._Find_next(pos);
        while(pos<N)
        {
            v.pb(pos);
            pos=oc._Find_next(pos);
        }
        for(auto x:v)
            cout<<x<<' ';///position of occurences
        cout<<nl;
        v.clear();
        cin>>l>>r;///number of occurences from l to r,where l and r is 1-indexed
        if(sz>r-l+1)
            cout<<0<<nl;
        else
            cout<<(oc>>(l-1)).count()-(oc>>(r-sz+1)).count()<<nl;
    }
    return 0;
}
